\documentclass[12pt]{article} 
%
%
%
\usepackage{listings}
\usepackage{bytefield}

\usepackage{paracol}

\usepackage[utf8x]{inputenc}
\usepackage[hebrew,english]{babel}
\usepackage{hebfont}
%
\usepackage{lastpage}
\usepackage{geometry}[1in]
\usepackage{graphicx}
%
\begin{document}
\hfil
\includegraphics{mtanew.png}
\hfil
\sethebrew
\par\noindent
\underline{\bf
מספר זהות:
}
\par\noindent
\fbox{\phantom{\Large 9}}
\fbox{\phantom{\Large 9}}
\fbox{\phantom{\Large 9}}
\fbox{\phantom{\Large 9}}
\fbox{\phantom{\Large 9}}
\fbox{\phantom{\Large 9}}
\fbox{\phantom{\Large 9}}
\fbox{\phantom{\Large 9}}
\fbox{\phantom{\Large 9}}

\hfill
\begin{minipage}{1.4in}
סמסטר א, מועד א.
\par\noindent
תאריך:
\L{12/2/2018}
\par\noindent
שעה:
\L{0900}
\par\noindent
משך הבחינה:
\L{3}
שעות.
\par\noindent
חומר עזר: אסור
\par\noindent
\end{minipage}
\vfill
{
\hfil
\Large
בחינה בקורס:
\underline{\bf
מבוא למערכות הפעלה
}
\hfil
}
\vspace{1Em}
\par\noindent
{
\large
\hfil
מרצה: ד''ר כרמי מרימוביץ
}
\par\noindent
{
\large
\hfil
מתרגל: מר צבי מלמד
}

\vspace{2Em}
\hfil
\fbox{
\begin{minipage}{3in}
\huge\bf
\par\noindent
\hfil
\phantom{
שורה ריקה
}
\hfil

\par\noindent
\hfil
מדבקית
\hfil
\par\noindent
\hfil
ברקוד
\hfil
\par\noindent
\hfil
\phantom{
שורה ריקה
}
\hfil

\end{minipage}
}


\hfil
\vspace{2Em}
\par\noindent
\underline{\bf
הנחיות:
}
\par\noindent
טופס הבחינה כולל 
\L{\pageref{LastPage}}
 עמודים )כולל עמוד זה(.
\par\noindent
{\bf
{\Large
קוד לא קריא לא יבדק!
}
\par\noindent
יש לענות בשטח המוקצה לכך.
}
\par\noindent
\vfill
{
\hfil
\fontsize{60}{20}\selectfont
\bf
בהצלחה!
\hfil
}


%start hebrew paragraph
\sethebrew
\newpage
\begin{enumerate}
\item
)03 נק'(
עליכם לממש בקרנל
\L{\tt xv6}
 קריאות מערכת לניהול השעיית/הערת תהליכים באופן הבא. ב-\L{user-mode}
 הקריאות נראות כך:

\hfill\L{\lstinline$int cond_wakeup(int pid);$}
\par\noindent
\hfill\L{\lstinline$int cond_sleep(int cnt);$}

)אין צורך לממש את הבאת הארגומנטים מ-\L{user-mode}.(
 הקריאה 
\L{\tt cond\_sleep}
תשעה את התהליך הקורא מריצה.
התהליך המושעה ימשיך לרוץ לאחר שתהליכים אחרים יבצעו סה"כ
\L{\tt cnt}
פעמים
\L{\tt cond\_wakeup}
עם ה-\L{\tt pid}
של התהליך המושעה.
 קריאה ל-\L{\tt cond\_wakeup}
 על תהליך שאינו מושעה אינה עושה דבר.
 )כלומר
\L{\tt cond\_sleep}
 נכנס להשעיה לא משנה כמה פעמים קראו לפניו ל-\L{cond\_wakeup}.(
\unsethebrew
\begin{lstlisting}
struct spinlock tickslock;
int sys_sleep(void)
{
  int n;
  uint ticks0;
  
  if(argint(0, &n) < 0)
    return -1;
  acquire(&tickslock);
  ticks0 = ticks;
  while(ticks - ticks0 < n){
    if(proc->killed){
      release(&tickslock);
      return -1;
    }
    sleep(&ticks, &tickslock);
  }
  release(&tickslock);
  return 0;
}
\end{lstlisting}
\sethebrew
\newpage
\begin{center}
{\bf\large
מקום עבור תשובה 1
}
\end{center}
\newpage
\item
)02 נק'(
בשאלה זו סביבת העבודה הינה 
\L{xv6}
במצב קרנל.
עליכם לכתוב רוטינה בקרנל שחתימתה

\hfill\L{\lstinline$int dict(char *filename, char *key, int *value);$}

הפרמטר הראשון הוא שם קובץ )מסתיים ב-\L{null}(.
הקובץ מורכב מרשומות במבנה הבא:

\hfill\L{\lstinline$struct pair{$}

\hfill\L{\lstinline$   char key[12];$}

\hfill\L{\lstinline$   int value;$}

\hfill\L{\lstinline$};$}

על הפונקציה לחפש בקובץ רשומה ששדה המפתח שלה שווה למחרוזת שניתנה בפרמטר השני
)גם כן מסתיים ב-\L{null}(.
במידה ורשומה כזו נמצאה יש להחזיר בפרמטר השלישי את ערך השדה
\L{\lstinline$value$}
של הרשומה.
ערך הפונקציה יהיה 0 במקרה זה.
במידה ולא נמצאה רשומה מתאימה הפונקציה תחזיר $-1$.
\unsethebrew
\begin{lstlisting}[tabsize=3,mathescape]
int exec(char *path, char **argv) {
	char *s, *last;
	int i, off;
	uint argc, sz, sp, ustack[3+MAXARG+1];
	struct elfhdr elf;
	struct inode *ip;
	struct proghdr ph;
	pde_t *pgdir, *oldpgdir;
	struct proc *curproc = myproc();

	begin_op();

	if ((ip = namei(path)) == 0){
		end_op();
		cprintf("exec: fail\n");
		return -1;
	}
	ilock(ip);
	pgdir = 0;

	// Check ELF header
	if (readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
		goto bad;
	if (elf.magic != ELF_MAGIC)
		goto bad;

	if ((pgdir = setupkvm()) == 0)
		goto bad;

// Load program into memory.
	sz = 0;
	for (i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
		if (readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
			goto bad;
		if (ph.type != ELF_PROG_LOAD)
			continue;
		if (ph.memsz < ph.filesz)
			goto bad;
		if (ph.vaddr + ph.memsz < ph.vaddr)
			goto bad;
		if ((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
			goto bad;
		if (ph.vaddr % PGSIZE != 0)
			goto bad;
		if (loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
			goto bad;
	}
	iunlockput(ip);
	end_op();
	ip = 0;
	$\vdots$
	$\vdots$
bad:
	if (pgdir)
		freevm(pgdir);
	if (ip){
		iunlockput(ip);
		end_op();
	}
	return -1;
}


int loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset,
						 uint sz) {
	uint i, pa, n;
	pte_t *pte;

	if ((uint) addr % PGSIZE != 0)
		panic("loaduvm: addr must be page aligned");
	for (i = 0; i < sz; i += PGSIZE) {
		if ((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
			panic("loaduvm: address should exist");
		pa = PTE_ADDR(*pte);
		if (sz - i < PGSIZE)
			n = sz - i;
		else
			n = PGSIZE;
		if (readi(ip, P2V(pa), offset+i, n) != n)
			return -1
	}
	return 0;
}
\end{lstlisting}
\sethebrew
\newpage
\begin{center}
{\bf\large
מקום עבור תשובה 2
}
\end{center}
\quad
\newpage
%
\item
)05 נק'(
סביבת שאלה זו היא
\L{Linux}
ב-\L{user-mode}.



במערכת ליצור מטבעות דיגיטליים נתונים המבנה והפונקציות כלהלן:

\hfill\L{\lstinline$struct coinOS {$}

\hfill\L{\lstinline$	.....$}

\hfill\L{\lstinline$	int valid;$}

\hfill\L{\lstinline$};$}

\hfill\L{\lstinline$void create_coin(struct coinOS *);$}

\hfill\L{\lstinline$void check_coin(struct coinOS *);$}

המידע במבנה
\L{\lstinline$coinOS$}
מייצג מטבע תקין כאשר השדה
\L{\lstinline$valid$}
אינו אפס.

הפונקציה
 \L{\lstinline$create_coin$}
 מנסה ליצור מטבע, אך בסיום פעולתה  השדה
  \L{valid}
  {\bf
   אינו מוגדר.
  }
  
הפונקציה
 \L{\lstinline$check_coin$}
  בודקת את המבנה, ומציבה לשדה
  \L{valid}
   ערך 0 או 1.
   
   )ממבנה בו השדה 
   \L{\lstinline$valid$}
   הוא אפס ניתן להתעלם.(
   
   שתי הפונקציות הנ"ל אינן "נקיות" ומדי פעם גורמות לתוכנית המשתמשת בהן "לעוף".

לשתי הפונקציות הנ"ל קוראים ''החלק הכבד" בכל תוכנית שמשתמשת בהן.

%
\begin{enumerate}
\item
)52 נק'(
יש לכתוב תוכנית המייצרת, בלולאה אינסופית,
			 מטבעות תקינים וכותבת אותם )כלומר את המבנה המדובר( לקובץ ששמו ניתן על ידי הקבוע הבא:

\hfill\L{
\lstinline$#define COIN_FILE "<full path name of file on disk>"$
}

כדי לייצר כמה שיותר מטבעות  יש לשאוף לכך שהחלק הכבד ירוץ בכל רגע במספר תהליכים שהוא כמספר המעבדים  במחשב
)אך לא יותר(.
מספר המעבדים במחשב נתון על-ידי הקבוע הבא: 
\unsethebrew
\lstinline$#define NCPU 8$
\sethebrew


מירב הנקודות ינתנו לפתרונות פשוטים ואלגנטיים )ונכונים(.  
\newpage
\begin{center}
{\bf\large
מקום עבור תשובה 3א
}
\end{center}
\newpage
%
\item
)52 נק'(
בסעיף זה יש לכתוב תוכנית המבצעת אותה משימה כמו בסעיף הקודם.
הפעם עומדת לרשותנו
{\bf
תוכנית
}
בשם
 \L{fastCoin}
  והפונקציה:
  
\hfill\L{
\lstinline$void make_perfect_coin(struct coinOS *);$
}

התכנית
\L{fastCoin}
 מייצרת מטבע כמעט תקין 
 {\bf
אחד,
}
כותבת אותו אל ה-\L{standard error} )כלומר ל-\L{file descriptor} 2(,
ומסיימת.
תוכנית זו אינה מתרסקת, ובסעיף זה היא החלק הכבד ביצירת מטבע.
הפונקציה 
\L{\lstinline$make_perfect_coin$}
מקבלת מטבע כמעט תקין והופכת אותו לתקין.
 
 התוכנית
\L{fastCoin}
נכתבה מתוך מחשבה שתרוץ כתכנית יחידה על המחשב,
 	 ללא אמצעי סנכרון )במקרה שכמה תכניות כאלו כותבות לאותו קובץ, עלול להיווצר מצב מירוץ(.
    התכנית נתונה
    \L{as-is},
      כלומר אנו יכולים להשתמש בה, אבל אין באפשרותנו לשנות אותה.

 בגלל אילוצים שונים )למשל הופעה בשאלה בבחינה(, רק התהליך הראשי יכול לקרוא לפונקציה  
 \L{\lstinline$make_perfect_coin$}.
  ולכן, רק התהליך הראשי יכול לבצע את "הגימור הסופי" של המטבע, ולכתוב אותו לקובץ 
  \L{\lstinline$COIN_FILE$}.
  
  לידיעתכם, בפייפ יש מספיק מקום למבנה.

גם כאן, מירב הנקודות לפתרונות פשוטים אלגנטיים )ונכונים(.
\newpage
\begin{center}
{\bf\large
מקום עבור תשובה 3ב
}
\end{center}
\newpage

\end{enumerate}

\end{enumerate}
%
\newpage
\unsethebrew
\newpage
\includegraphics[width=\textwidth]{flock.png}
\includegraphics[width=\textwidth]{wait.png}
\includegraphics[width=\textwidth]{wait1.png}
\includegraphics[width=\textwidth]{wait2.png}
\includegraphics[width=\textwidth]{pipe.png}
\includegraphics[width=\textwidth]{sempost.png}
\includegraphics[width=\textwidth]{semwait.png}
\quad \vspace{2Em}
\par\noindent
\includegraphics[width=\textwidth]{semgetvalue.png}
\includegraphics[width=\textwidth]{kill.png}
%
\end{document}
