//
// Semantics like xv6, using the same vector
//

#define KERNBASE 0x80000000 // First kernel virtual address

#define EXTMEM 0x100000 // Start of extended memory
#define KERNLINK (KERNBASE+EXTMEM) // Address where kernel is linked

#define PHYSTOP 0xE000000 // Top physical memory
#define DEVSPACE 0xFE000000 // Other devices are at high addresses

static struct kmap {
	void *virt;
	uint phys_start;
	uint phys_end;
	int perm;
} kmap[] = {
{ (void*)KERNBASE, 0, EXTMEM, PTE_W}, // I/O space
{ (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0}, // kern text+rodata
{ (void*)data, V2P(data), PHYSTOP, PTE_W}, // kern data+memory
{ (void*)DEVSPACE, DEVSPACE, 0, PTE_W}, // more devices
};

void *setupkvm2() {
	unsigned long *tbl0, *tbl1;
	unsigned long pddr, vaddr, i0, i1;
	struct kmap *k;
	
	if ((tbl0 = kalloc()) == 0)
		return (NULL);
		
	memset(tbl0, 0, 4096);
	
	for (k = kmap; k < &kmap[NELEM(kmap)]; k++) {
		for (paddr = k->phys_start, vaddr = k->virt;
			 paddr < k->phys_end;
			 paddr += 4096, vaddr += 4096) {
			i0 = (vaddr >> 22) & 1023;
			i1 = (vaddr >> 10) & 1023;
		
		if ((tbl0[i0] & 1) != 0)
			tbl1 = p2v(tbl0[i0] & ~4095);
		else {
			if ((tbl1 = kalloc()) == 0)
				goto bad;
			tbl0[i0] = v2p(tbl1) | 3;
		}
		tbl1[i1] = (paddr | (k->perm|1));
	}
	return (tbl0);
	
bad:
	for (i = 512; i < 1024 ; i++)
		if (tbl0[i] != 0)
			kfree(p2v(tbl0[i) & ~4095));

	kfree(tbl0);
	return (NULL);
}